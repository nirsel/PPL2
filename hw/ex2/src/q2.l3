(define append 
  (lambda (lst1 lst2)
      (if (empty? lst1) 
      lst2
      (cons (car lst1) 
            (append (cdr lst1) lst2))))
)


(define reverse 
  (lambda (lst)
        (if (empty? lst)
          '()
          (append (reverse (cdr lst)) (list (car lst)))
        )
  )
)

(define duplicate-first
  (lambda (lst item num)
    (if (zero? num)
        lst
        (duplicate-first (cons item lst) item (- num 1)))))

(define duplicate-items
  (lambda (lst dup-count)
    (if (empty? lst)
        lst
        (append (duplicate-first '() (car lst) (car dup-count)) (duplicate-items (cdr lst) (append (cdr dup-count) (list(car dup-count))))))))


(define remove-all
  (lambda (val lst)
    (if (empty? lst)
        '()
    (if (not (equal? val (car lst)))
        lst
        (remove-all val (cdr lst))))))
  
(define payment
  (lambda (n coins-lst)
        (if (zero? n)
        1
        (if (or (< n 0) (empty? coins-lst))
        0
        (if (< (- n (car coins-lst)) 0)
          (payment n (cdr coins-lst))
          (if (and (not (empty? (cdr coins-lst))) (= (car coins-lst) (cadr coins-lst)))
              (+ (payment n (remove-all (car coins-lst) coins-lst)) (payment (- n (car coins-lst)) (cdr coins-lst)))
          (+ (payment n (cdr coins-lst)) (payment (- n (car coins-lst)) (cdr coins-lst)))))))))
                               
(define compose-n
  (lambda(f n)
        (if (= n 1)
            (lambda (x) (f x))
         (lambda (x) (f ((compose-n f (- n 1)) x)))
  )))

